## Файлы
>Главный файл кода — mani.cpp, который в некотором смысле центр управления программой. Внутри него только рычаги. Т. е. внутри него только описывается необходимая последовательность вызовов.   
>Файл реализации — .cpp, в котором реализуется основная часть программы. Если главный файл называть центром управления, то файл реализации — это механизм, которым управляют.   
>Файл заголовков — .h, который содержит общее описание используемых функций или просто названия переменных. Это эскиз некоторой программы. Этот файл используется для того, чтобы основной файл программы знал о существовании рычагов описанного в файле реализации механизма. 


конструктор
## типы данных

целочисленные:

>short a = -10;
>unsigned short b = 10;
>int c = -30;
>unsigned int d = 60;
>long e = -170;
>unsigned long f = 45;
>long long g = 89;

вещественные:

>float a = -10.45;
>double b = 0.00105;
>long double c = 30.890045;

строковые:

>char
>string (c библиотекой <string>)

## Set и Get
>Модификатор - изменение чего-либо, принято  использовать `Set();
Seting - установка. Устанавливаем значение в класс
~~~C++
private:
	int number;  // наша переменная
public:
	void set_number(int value) // set и тип переменной которую принимаем
	{
	  number = value;//Устанавливаем значение для поля number   
	}
~~~
>Селектор - (от лат. сортировщик) - применяет
Get - получить. Позволяет получить из класса .
Get  должен иметь тот-же тип данных которые и возвращает.
~~~ C++
private:
	int number;  // наша переменная
public:
	int get_number() // get и переменная
	{    
	  return number;  // которую возвращают
	}
~~~

## Конструктор и деструктор
Позволяет  инициализировать переменные которые входят в состав класса
во время объявления.

Обязательно должны быть в `public:

Конструктор без параметров -  просто инициализирует переменные
Конструктор с параметрами - позволяет задать значения переменных во время
создания нового класса. Пример `NameClass A (1, 2, 3);

Деструктор вызывается как `~NameClass(){};` позволяет уничтожить из памяти
инициализированные переменные

## Ссылки и указатели
Указатель - это переменная, у неё есть свое значение и адрес памяти.
Значение указателя - адрес другой переменной.
Объявляется `int *pointer;` - указатель на переменную типа Int
Где звёздочку писать не имеет значения `int* p1; int *p2; int * p3;`
Нельзя несколько объявлять несколько указателей по одним типом ~~int* p1, p2;~~

Чтобы передать адрес переменной указателю нужно присвоит к указатель переменную со знаком &
Переменная получает адрес пример ` p1=&x;` где х обычна переменная.
~~~ C++
  int  x= 2;
  int *p1;
  p1 = &x;// передаём значение х указатель p1
  cout << p1 << endl; // покажет адрес указателя
  cout << *p1 << endl; // покажет значение хранящееся в х
  cout << x << endl; // покажет переменную х
~~~  

Если требуется, чтобы функция вернула несколько значений используется указатели. Пример:
~~~ C++
int swap(int *a,  int *b)
{// функция переворачивает значение переменных местами
    int temp = *a;// запоминаем значение a
    *a = *b;// b присваивается a
    *b = temp;// присваиваем b значение a которое запомнил temp
}

int main()
{
   int q=1; int w=2;
   swap(&q, &w);// передаём значение указателем в функции
   cout << q << " - " << w << endl; // результат 2 - 1
}
~~~
#### this
Ключевое слово this представляет указатель на текущий объект данного класса.
Через this мы можем обращаться внутри класса к любым его членам
Указатель объекта на сомого себя, знание объекта где (память) он находится    


## Динамическая память
Стек -(англ. stack "стопка")бестрактный тип данных, представляющий собой список
элементов, организованных по принципу  «последним пришёл — первым вышел».
Объем памяти для стека выделяется немного.
В динамической памяти можно выдавать горазда больше.

Оператор delete не чего не удалят он возвращает память которая была выделена ранее
обратно в оперативную.

## Русские буквы в консоли
Работает в Visio studio, в Qt Creator нет
~~~ C++
    <windows.h>// - библиотека
    SetConsoleCP(1251);// установка кодовой страницы win-cp 1251 в поток ввода
    SetConsoleOutputCP(1251); // для вывода
~~~

Qt Creator `setlocale (LC_ALL, "");` не помогает
Решение: библиотека - `#include <QTextStream>`
~~~ C++
    QTextStream cin(stdin); cin.setCodec("CP866"); // ввода
    QTextStream cout(stdout); cout.setCodec("CP866"); // вывод
    cout << QString::fromUtf8("Текст ");
~~~

### Виртуальные функции    
К механизму виртуальных функций прибегают когда - в роизводном классе требуется
свой вариант некоторой компонентной функции.
Практически каждый класс, имеющий виртуальную функцию, должен иметь виртуальный
деструктор.
``` C++
  class Base

  public:
    virtual void print(){cout<<”\nBase”;}
. . .
  };
  class Derive : public Base
  {
  public:
    void print(){cout<<”\n Derive”;}
  };
  void main()
  {
    Base B,*bp;
    Derive D,*dp;
    bp=&B;
    dp=&D;
  //указатель базового класса ставится на объект
  //производного класса
  Base *p = &D;
  bp –>print(); // вызывается метод для Base
  dp –>print(); // вызывается метод для Derive
  p –>print(); // вызывается метод для Derive
  }
```

## Несколько файлов
Правила:  
* `# progma once` - пишется в начале .h файла что бы не было ошибки при объявлении повторяющихся сущностей
* не писать using namespace в .h иначе возможно замусорить глобальное пространство имён целого проекта.
> .h  - заголовочный файл, описывает объекты    
  .срр - здесь реализовываются функции или методы.    
  В main потом вызывать только дочерний класс, вызов обоих приведёт к ошибке, повторное определение класса
>   
### Сборка из нескольких файлов  командной строке
`g++ -c main.cpp add.cpp -o main` - где main.cpp основной файл, add.cpp второй, main имя проекта   

### Системная пауза
``` C++
#include <cstdlib>
system("pause");
```

**std::endl** не только вставляет символ перехода на новую строку, но еще и очищает буфер.
В большинстве простых задач это незаметно, но данный момент может на многое повлиять.
Из-за очистки буфера при каждом  применении, функция может, как упростить  работу с потоками,
так и сделать ее в несколько раз дольше - например, при записи крупного объема данных в файл –
программа каждый раз будет останавливаться, и записывать данные на диск.


## перегрузка в классе   
Синтаксис перегрузки операторов очень похож на определение функции с именем operator@, где @ — это идентификатор оператора (например +, -, <<, >>)

## Конструктор   
~~~ C++
// Инициализация в классе
	Class_name() // конструктор без параметров
	{
		min = 0; .....; // инициализация переменных
	}
// создание объекта в main.cpp
  Class_name a;
/* --------------------------------------------- */
// Инициализация в классе
	Class_name(int n, ...) // конструктор без параметров
	{
		min = n; .....; // инициализация переменных
	}
// создание объекта в main.cpp
  Class_name a {1, .....}; // присваиваем значения для переменных при объявлении нового объекта   
~~~
