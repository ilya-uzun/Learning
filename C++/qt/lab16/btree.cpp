#include "btree.h"

Btree::Btree()
{
    root = 0; // Корневой узел без дочерних элементов
}

Btree::~Btree()
{
    destroy_tree(); //При удалении дерева, необходимо удалить все //элементы
}

void Btree::destroy_tree(node* leaf)
{
    if(leaf != 0)    //Если узел дерева существует
    {
        //Функция вызовет сама себя
        destroy_tree(leaf->left);   //сначала для левого потомка,
        destroy_tree(leaf->right);  //после для правого потомка.
        delete leaf;     //Если потомков нет, она удалит
        //Узел, полученный в качестве параметра //функции
    }
}

void Btree::insert(int key) //Функция, доступная для элементов, которые не   являются членами класса
{                           //Сначала проверит корневой элемент
    if(root!=0) insert(key, root); //Если он не инициализирован,то вызовется рекурсивная функция для добавления элемента.
    else                           // Иначе Функция поместит новое значение:
    {
        root = new node;      //инициализируется корневой элемент
        root->key_value=key; //поместится ключевое значение
                             //в соответствующую ячейку структуры.
        root->left=0;        //Инициализируется указатель на левы
        root->right=0;       //и правый элемент как NULL
    }
}
//Рекурсивная функция для вставки элемента.
void Btree::insert(int key, node* leaf) //(Новое ключевое значение, указатель на //текущий узел)
{
    if(key < leaf->key_value) //Если новое ключевое значение меньше чем //ключевое значение в узле
    {
        if(leaf->key_value != 0) //И если левый указатель узла инициализирован
        {
            insert(key, leaf->left);  //Функция вызывает саму себя, для левого //узла потомка
        }else //Иначе (если левый потомок не //инициализирован)
        {
            leaf->left = new node; //Функция создаст и поместит новый элемент на //место левого потомка.
            leaf->left->key_value = key; //Внесёт новое ключевое значение в элемент.
            leaf->left->key_value = 0; //Установит левый дочерний указатель
            leaf->left->right = 0;     //и правый дочерний указатель в NULL.
        }
    }//if(key < leaf->key_value)
    else if (key >= leaf->key_value) //Иначе Если новое ключевое значение не //меньше ключевого значения в узле
    {
        if(leaf->right != 0) //И если правый указатель инициализирован,
        {
            insert(key, leaf->right); //То функция вызывает саму себя, для правого потомка
        } else   //Иначе(если правый потомок не //инициализирован)
        {
            leaf->right = new node; //Функция создаст и поместит новый элемент на //место левого потомка.
            leaf->right->key_value = key; //Внесёт новое ключевое значение в элемент.
            leaf->right->key_value = 0; //Установит левый дочерний указатель
            leaf->right->right = 0;     //и правый дочерний указатель в NULL.
        }
    }//else if (key >= leaf->key_value)
}

node* Btree::search(int key, node* leaf)
{
    if(leaf != 0)
    {
        if(key == leaf->key_value) return leaf;
        if(key < leaf->key_value) return search(key, leaf->left);
            else return search(key, leaf->right);
    }
    else return 0;
}
